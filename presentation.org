#+title: Definite Clause Gramatike
#+author: Mislav Zanic

* Beskontekstne Gramatike
#+begin_src
s    ->  np   vp
np   ->  det  n
vp   ->  v    np
vp   ->  v
det  ->  a
det  ->  the
n    ->  woman
n    ->  man
v    ->  shoots
#+end_src
** Prepoznavanje BKG koristeci append
*** Append
#+begin_src prolog :tangle ./cfg_append.pl
append([],X,X).
append([H|T1],Y,[H|T2]) :- append(T1,Y,T2).
#+end_src

*** Gramatika
#+begin_src prolog :tangle ./cfg_append.pl :session :goal s([a,man,shoots])
s(Z) :- np(X),vp(Y),append(X,Y,Z).
np(Z) :- det(X),n(Y),append(X,Y,Z).
vp(Z) :- v(X),np(Y),append(X,Y,Z).
vp(Z) :- v(Z).

det([a]).
det([the]).
n([woman]).
n([man]).
v([shoots]).
#+end_src

*** Problem
- prolog ne koristi ulaznu recenicu kako bi pogodio, npr.
  #+begin_src
    [trace]  ?- s([a,man,shoots]).
      Call: (10) s([a, man, shoots]) ?
      Call: (11) np(_8748) ?
      Call: (12) det(_9500) ?
      Exit: (12) det([a]) ?
      Call: (12) n(_11008) ?
      Exit: (12) n([woman]) ?
      Call: (12) append([a], [woman], _8748) ?
      Call: (13) append([], [woman], _13278) ?
      Exit: (13) append([], [woman], [woman]) ?
      Exit: (12) append([a], [woman], [a, woman]) ?
      Exit: (11) np([a, woman]) ?
      Call: (11) vp(_16304) ?
      Call: (12) v(_17056) ?
      Exit: (12) v([shoots]) ?
      Call: (12) np(_18564) ?
      Call: (13) det(_19316) ?
      Exit: (13) det([a]) ?
      Call: (13) n(_20824) ?
      Exit: (13) n([woman]) ?
      Call: (13) append([a], [woman], _18564) ?
      Call: (14) append([], [woman], _23094) ?
      Exit: (14) append([], [woman], [woman]) ?
      Exit: (13) append([a], [woman], [a, woman]) ?
      Exit: (12) np([a, woman]) ?
      Call: (12) append([shoots], [a, woman], _16304) ?
      Call: (13) append([], [a, woman], _26882) ?
      Exit: (13) append([], [a, woman], [a, woman]) ?
      Exit: (12) append([shoots], [a, woman], [shoots, a, woman]) ?
      Exit: (11) vp([shoots, a, woman]) ?
      Call: (11) append([a, woman], [shoots, a, woman], [a, man, shoots]) ?
  #+end_src

- prvi guess koji je prolog radio je /a woman shoots a woman/
- ovo je samo DIO trace-a, jako mali dio...
- ocito nas ovaj nacin nece dovesti daleko, dovoljno je dobro za jako male gramatike, ali, kod iole vecih, imat cemo problema

*** Append na pocetku
- bolje, ali radimo append na nepoznatim varijablama npr. ~append(_808, _831, Z).~
  - ako se sjetimo predavanja, od tuda dolazi neefikasnost ~append~ funkcije

#+begin_src prolog :tangle append_first.pl
s(Z):- append(X,Y,Z),  np(X),  vp(Y).
np(Z):- append(X,Y,Z),  det(X),  n(Y).
vp(Z):- append(X,Y,Z),  v(X),  np(Y).
vp(Z):- v(Z).

det([the]).
det([a]).
n([woman]).
n([man]).
v([shoots]).
#+end_src

** Prepoznavanje BKG koristeci razliku lista
*** Razlika lista
- [a,woman,shoots,a,man,a,b,c,d] [a,b,c,d] == [a,woman,shoots,a,man]

#+begin_src prolog :tangle ./difference_list.pl
s(X,Z) :- np(X,Y),vp(Y,Z).
np(X,Z) :- det(X,Y),n(Y,Z).
vp(X,Z) :- v(X,Y),np(Y,Z).
vp(X,Z) :- v(X,Z).

det([the|W],W).
det([a|W],W).

n([man|W],W).
n([woman|W],W).

v([shoots|W],W).
#+end_src

- poanta je iz cijele recenice prepoznati pojedine gramaticke djelove

#+begin_src
[trace]  ?- s([a,man,shoots],[]).
   Call: (10) s([a, man, shoots], []) ?
   Call: (11) np([a, man, shoots], _7602) ?
   Call: (12) det([a, man, shoots], _8358) ?
   Exit: (12) det([a, man, shoots], [man, shoots]) ?
   Call: (12) n([man, shoots], _7602) ?
   Exit: (12) n([man, shoots], [shoots]) ?
   Exit: (11) np([a, man, shoots], [shoots]) ?
   Call: (11) vp([shoots], []) ?
   Call: (12) v([shoots], _12884) ?
   Exit: (12) v([shoots], []) ?
   Call: (12) np([], []) ?
   Call: (13) det([], _15148) ?
   Fail: (13) det([], _15148) ?
   Fail: (12) np([], []) ?
   Redo: (11) vp([shoots], []) ?
   Call: (12) v([shoots], []) ?
   Exit: (12) v([shoots], []) ?
   Exit: (11) vp([shoots], []) ?
   Exit: (10) s([a, man, shoots], []) ?
#+end_src

- ovo je veliko poboljsanje
- ovo je cijeli trace, ne samo dio

- tu mozemo primjetiti da se nasa originalna (~[a,man,shoots]~) recenica propagira do ~det~ dijela gramatike, gdje se odmah prepoznaje ~[a]~

- mane ovog pristupa su
  - sam po sebi nije toliko "intuitivan"
  - nespretan je za napisat (tko ce pamtit da je ~([a|W],[W]) == [a]~)

* DCG
- lijepa notacija za pisanje gramatika
  #+begin_src prolog :tangle ./dcg_example.pl :session :gola s([a,man,shoots,a,woman],[])
    s    -->  np,vp.
    np   -->  det,n.
    vp   -->  v,np.
    vp   -->  v.

    det  -->  [a].
    det  -->  [the].
    n    -->  [woman].
    n    -->  [man].
    v    -->  [shoots].
  #+end_src

- u pozadini je to razlika listi, DCG je samo tzv. /syntactic sugar/ pomocu kojeg mozemo pisati gramatike na prirodan nacin
  - to se vidi iz poziva ~s(X,[]).~
- efikasnost razlike lista i lijepa notacija (slicna BKG-u)

** Rekurzivna pravila
#+begin_src prolog :tangle ./dcg_example.pl
  s    --> s,conj,s.
  conj --> [and].
  conj --> [or].
  conj --> [but].
#+end_src

- ako ova pravila (specificno, pravilo za ~s~) stavimo na pocetak i pokrenemo query ~s([a,woman,shoots],[]).~, prolog ce se zaloopati
  - prolog ce iskljucivo pokusavati zadovoljiti prvo pravilo

- sada dobijemo odgovor na query ~s([a,woman,shoots],[]).~, ali ako pitamo prolog ~s([woman,shoots], []).~, prolog se ponovo zaloopa
  - tu se ne mozemo izvuci sa mijenjanjem redosljeda (~s --> s,conj,s.~ i ~s --> conj,s,s.~ nemaju istu semantiku)

- rjesenje je ono standardno, dodaj novu varijablu

  #+begin_src prolog :tangle ./better_dcg_example.pl
    s      --> novi_s.
    s      --> novi_s,conj,s.
    novi_s --> np,vp.
    np     --> det,n.
    vp     --> v,np.
    vp     --> v.

    det    --> [a].
    det    --> [the].
    n      --> [woman].
    n      --> [man].
    v      --> [shoots].
    conj   --> [and].
    conj   --> [or].
    conj   --> [but].
  #+end_src

** Primjeri DCG-a
*** Propozicionalna logika
#+begin_src
  prop  ->  p
  prop  ->  q
  prop  ->  r
  prop  -> ¬ prop
  prop  -> (prop ∧ prop)
  prop  -> (prop ∨ prop)
  prop  -> (prop → prop)
#+end_src

#+begin_src prolog :tangle prop_log.pl
  prop        --> not,prop.
  prop        --> otv,simple_prop,and,prop,zatv.
  prop        --> otv,simple_prop,or,prop,zatv.
  prop        --> otv,simple_prop,impl,prop,zatv.
  prop        --> simple_prop.

  simple_prop --> [p].
  simple_prop --> [q].
  simple_prop --> [r].
  and         --> [and].
  or          --> [or].
  impl        --> [impl].
  not         --> [not].
  otv         --> ['('].
  zatv        --> [')'].
#+end_src

*** Aritmetika u N (djelomicna barem)
#+begin_src prolog :tangle ./aritmetika_N.pl :session :goal izraz([otv,otv,2,2,3,+,3,zatv,*,4,zatv,^,5],[])
  izraz --> clan,plus,izraz.
  izraz --> clan.
  clan --> faktor,puta,clan.
  clan --> faktor.
  faktor --> baza,na,faktor.
  faktor --> baza.
  baza --> broj.
  baza --> otv,izraz,zatv.

  plus --> [+].
  puta --> [*].
  na --> [^].
  otv --> ['('].
  zatv --> [')'].

  broj --> [0].
  broj --> [1],pbroj.
  broj --> [2],pbroj.
  broj --> [3],pbroj.
  broj --> [4],pbroj.
  broj --> [5],pbroj.
  broj --> [6],pbroj.
  broj --> [7],pbroj.
  broj --> [8],pbroj.
  broj --> [9],pbroj.

  pbroj --> [].
  pbroj --> broj.
#+end_src

#+RESULTS:
: true.

* DCG++
** Dodatni argumenti
- prava moc DCG-a

- nasa pocetna gramatika uz neka dodatna pravila
  #+begin_src prolog ./pronouns_exaple.pl
    s    -->  np,vp.
    np   -->  det,n.
    vp   -->  v,np.
    vp   -->  v.

    det  -->  [a].
    det  -->  [the].

    n    -->  [woman].
    n    -->  [man].

    v    -->  [shoots].
  #+end_src

- sto sa recenicama oblika "He shoots her"
  - mozemo dodati nova pravila

  #+begin_src prolog ./pronouns_exaple.pl
    pro  -->  [he].
    pro  -->  [she].
    pro  -->  [him].
    pro  -->  [her].

    np   -->  pro.
  #+end_src

- Ovo radi, ali nasa gramatika prepoznaje i recenice oblika "Her shoots she"
  - nasa gramatika ne zna raspoznati sto je subjekt, a sto objekt

- ovo mozemo rjesiti tako da uvedemo dodatne varijable
  #+begin_src prolog ./extra_pronouns.pl
    s  -->  np_subject,vp.
    np_subject  -->  det,n.
    np_object    -->  det,n.
    np_subject  -->  pro_subject.
    np_object    -->  pro_object.

    vp  -->  v,np_object.
    vp  -->  v.

    det  -->  [the].
    det  -->  [a].

    n  -->  [woman].
    n  -->  [man].

    pro_subject  -->  [he].
    pro_subject  -->  [she].
    pro_object  -->  [him].
    pro_object  -->  [her].

    v  -->  [shoots].
  #+end_src
- ali to nije dobro rjesenje
  - tu smo napravili veliku promjenu u nasem DCG-u, tocnije poduplali smo pravila za ~np~
  - za iduce promjene trebali bi dodati jos vise novih pravila

- dobro rjesenje dolazi u obliku dodatnih argumenata

  #+begin_src prolog
    s --> np(subject),vp

    np(_) --> det,n.
    np(X) --> pro(X).

    vp --> v,np(object).
    vp --> v.

    det --> [the].
    det --> [a].

    n --> [woman].
    n --> [man].

    pro(subject) --> [he].
    pro(subject) --> [she].
    pro(object) --> [him].
    pro(object) --> [her].

    v --> [shoots].
  #+end_src

*** Stablo parsiranja
- dodatni argumenti nam mogu pomoci pri izgradnji stabla parsiranja
  #+begin_src prolog ./simple_parser.pl :session :goal s(X,[a,woman,shoots,a,man],[])
    s(s(NP,VP)) --> np(NP),vp(VP).
    np(np(DET,N)) --> det(DET),n(N).
    vp(vp(V,NP)) --> v(V), np(NP).
    vp(vp(V)) --> v(V).

    det(det(the)) --> [the].
    det(det(a)) --> [a].

    n(n(woman)) --> [woman].
    n(n(man)) --> [man].

    v(v(shoots)) --> [shoots].
  #+end_src

*** BKG++
- "trik" sa dodatnim varijablama nam moze pomoci u prepoznavanju jezika koji nisu u BK
- npr. jezik  \( {a^n b^n c^n, n \in N_+ } \)
  #+begin_src prolog :tangle ./bkg_pp.pl :session :goal s(succ(succ(succ(0))), X, [])
    s(Count) --> ablok(Count),bblok(Count),cblok(Count).

    ablok(0) --> [].
    ablok(succ(Count)) --> [a],ablok(Count).

    bblok(0) --> [].
    bblok(succ(Count)) --> [b],bblok(Count).

    cblok(0) --> [].
    cblok(succ(Count)) --> [c],cblok(Count).

  #+end_src

  #+RESULTS:
  | X = [a | a | a | b | b | b | c | c | c]. |
